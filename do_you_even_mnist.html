<!--
TODOs
[] give the ability to the user to change type of similarty metrics from dot product simple to my product and show him the results
[] add a button to toggle color mode between true color and neuron color
[] calculate and display the accuracy of the neuron placements
[] add a tooltip to show the true label of each point when hovering over it
[] add a title and abstract to describe the visualization
[] style the elements to improve readability and aesthetics
[] 
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive t-SNE with Draggable Neurons on MNIST Data</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f9f9f9;
        }
        #title {
            font-size: 24px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        #abstract {
            max-width: 700px;
            text-align: center;
            margin-bottom: 20px;
            color: #555;
            font-size: 16px;
        }
        #container {
            position: relative;
            width: 80vw;
            height: 80vh;
            max-width: 600px;
            max-height: 600px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
        }
        .neuron {
            fill-opacity: 0.8;
            cursor: move;
        }
        .point {
            fill-opacity: 0.7;
            cursor: pointer;
        }
        #accuracy {
            margin-top: 10px;
            font-size: 16px;
            color: #333;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 13px;
        }
        .similarityMetric, #toggleColorMode {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .similarityMetric:hover, #toggleColorMode:hover {
            background-color: #0056b3;
        }
        .similarityMetric:focus, #toggleColorMode:focus {
            outline: none;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }
        #optimizeButton {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #optimizeButton:hover {
            background-color: #218838;
        }
        #optimizeButton:focus {
            outline: none;
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.5);
        }
    </style>
</head>
<body>
    <div id="title">Artificial Neurons that Matter: Reject Correlation, Embrace Orthogonality</div>
    <div id="abstract">Explore the MNIST dataset in 2D with t-SNE and draggable neurons to see their influence on data points based on score calculations.</div>
    <div>
        <button class="similarityMetric" data-metric="dotProduct">Dot Product</button>
        <button class="similarityMetric" data-metric="myProduct">My Product</button>
        <button class="similarityMetric" data-metric="euclidean">Euclidean Distance</button>
    </div>
    <div>
        <button class="colorMode" data-mode="true">True Label</button>
        <button class="colorMode" data-mode="neuron">Predicted Label</button>
    </div>
    <div>
        <button id="optimizeButton">Optimize Neurons</button>
    </div>
    <div id="container">
        <svg id="canvas" width="600" height="600"></svg>
        <div class="tooltip" style="display: none;"></div>
    </div>
    <div id="accuracy">Accuracy: Calculating...</div>

    <script>
        const svg = d3.select("#canvas");
        const tooltip = d3.select(".tooltip");
        const width = 600;
        const height = 600;
        let colorMode = 'neuron'; // Initialize color mode
        let similarityMetric = 'dotProduct'; // Initialize similarity metric

        // Load t-SNE data
        d3.csv("mnist_tsne.csv").then(data => {
            const xExtent = d3.extent(data, d => +d.x);
            const yExtent = d3.extent(data, d => +d.y);

            const xScale = d3.scaleLinear().domain(xExtent).range([50, width - 50]);
            const yScale = d3.scaleLinear().domain(yExtent).range([height - 50, 50]);

            // Initialize neurons with a unique color and ID for each digit
            const neurons = Array.from({ length: 10 }, (_, i) => ({
                id: i,
                x: Math.random() * width,
                y: Math.random() * height,
                color: d3.schemeCategory10[i],
                label: i
            }));

            const calculateScore = (neuron, x, y) => {
                const dx = x - neuron.x;
                const dy = y - neuron.y;
                const squaredDistance = dx * dx + dy * dy + 1e-8;
                const dotProductSquared = (x * neuron.x + y * neuron.y) ** 2;

                if (similarityMetric === 'dotProduct') {
                    return Math.sqrt(dotProductSquared);
                } else if (similarityMetric === 'myProduct') {
                    return dotProductSquared / squaredDistance;
                } else if (similarityMetric === 'euclidean') {
                    return Math.sqrt(squaredDistance);
                }
            };

            // Draw points for each digit in the t-SNE space
            svg.selectAll(".point")
                .data(data)
                .enter().append("circle")
                .attr("class", "point")
                .attr("r", 3)
                .attr("cx", d => xScale(+d.x))
                .attr("cy", d => yScale(+d.y))
                .attr("data-label", d => d.label)  // Store the true label
                .style("fill", "#666");

            // Add draggable neurons
            const neuronCircles = svg.selectAll(".neuron")
                .data(neurons)
                .enter().append("circle")
                .attr("class", "neuron")
                .attr("r", 10)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("data-id", d => d.id)
                .style("fill", d => d.color)
                .call(d3.drag()
                    .on("start", (event, d) => {
                        d3.select(event.sourceElement).raise();
                    })
                    .on("drag", function(event, d) {
                        d.x = Math.min(width, Math.max(0, event.x));
                        d.y = Math.min(height, Math.max(0, event.y));
                        d3.select(this)
                            .attr("cx", d.x)
                            .attr("cy", d.y);
                        updateColors();
                    }));

            function updateColors() {
                svg.selectAll(".point")
                    .style("fill", function(d) {
                        const x = xScale(+d.x);
                        const y = yScale(+d.y);

                        if (colorMode === 'true') {
                            return d3.schemeCategory10[d.label];  // True color based on label
                        } else {
                            let maxScore = -Infinity;
                            let bestNeuron = null;

                            neurons.forEach(neuron => {
                                const score = calculateScore(neuron, x, y);
                                if (score > maxScore) {
                                    maxScore = score;
                                    bestNeuron = neuron;
                                }
                            });

                            return bestNeuron ? bestNeuron.color : "#666";
                        }
                    });

                calculateAccuracy();
            }

            function calculateAccuracy() {
                let correctCount = 0;

                svg.selectAll(".point")
                    .each(function(d) {
                        const x = xScale(+d.x);
                        const y = yScale(+d.y);

                        let maxScore = -Infinity;
                        let bestNeuron = null;

                        neurons.forEach(neuron => {
                            const score = calculateScore(neuron, x, y);
                            if (score > maxScore) {
                                maxScore = score;
                                bestNeuron = neuron;
                            }
                        });

                        if (bestNeuron && bestNeuron.label == d.label) {
                            correctCount++;
                        }
                    });

                const accuracy = (correctCount / data.length) * 100;
                d3.select("#accuracy").text(`Accuracy: ${accuracy.toFixed(2)}%`);
            }

            // Tooltip for displaying point details
            svg.selectAll(".point")
                .on("mousemove", (event, d) => {
                    tooltip.style("display", "block")
                        .style("left", `${event.pageX + 10}px`)
                        .style("top", `${event.pageY - 20}px`)
                        .html(`Label: ${d.label}`);
                })
                .on("mouseout", () => {
                    tooltip.style("display", "none");
                });

            // Toggle button event listener
            d3.select("#toggleColorMode").on("click", () => {
                colorMode = colorMode === 'neuron' ? 'true' : 'neuron';
                updateColors();
            });

            // Button event listeners
            d3.selectAll(".similarityMetric").on("click", function() {
                similarityMetric = d3.select(this).attr("data-metric");
                updateColors();
            });

            // Button event listeners for color mode
            d3.selectAll(".colorMode").on("click", function() {
                colorMode = d3.select(this).attr("data-mode");
                updateColors();
            });

            // Button event listener for optimization
            d3.select("#optimizeButton").on("click", () => {
                const iterations = prompt("Enter the number of iterations for optimization:", "100");
                if (iterations !== null) {
                    optimizeNeurons(parseInt(iterations));
                }
            });

            function optimizeNeurons(iterations) {
                const learningRate = 0.01;
                const optimizer = tf.train.adam(learningRate);
                const batchSize = 100; // Process data in batches

                const neuronPositions = tf.variable(tf.tensor2d(neurons.map(n => [n.x, n.y])));

                function loss(batch) {
                    return tf.tidy(() => {
                        const losses = batch.map(d => {
                            const x = xScale(+d.x);
                            const y = yScale(+d.y);
                            const point = tf.tensor2d([[x, y]]);
                            const distances = tf.norm(tf.sub(neuronPositions, point), 'euclidean', 1);
                            const minDistance = distances.min();
                            return minDistance;
                        });
                        return tf.addN(losses).mean();
                    });
                }

                async function train() {
                    for (let i = 0; i < iterations; i++) {
                        for (let j = 0; j < data.length; j += batchSize) {
                            const batch = data.slice(j, j + batchSize);
                            optimizer.minimize(() => loss(batch));
                            await tf.nextFrame();
                        }
                    }
                    const optimizedPositions = neuronPositions.arraySync();
                    neurons.forEach((neuron, i) => {
                        neuron.x = optimizedPositions[i][0];
                        neuron.y = optimizedPositions[i][1];
                    });
                    updateColors();
                }

                train().then(() => {
                    neuronPositions.dispose();
                });
            }

            // Initial color update
            updateColors();
        });
    </script>
</body>

</html>