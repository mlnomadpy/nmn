<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artificial Neurons that Matter: Reject Correlation, Embrace Orthogonality</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
        }
        #title {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        #abstract {
            max-width: 700px;
            text-align: center;
            color: #555;
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
        }
        #container {
            display: flex;
            gap: 20px;
            width: 95vw;
            height: 80vh;
            max-width: 1200px;
            max-height: 600px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #main-canvas {
            flex: 2;
            border-right: 1px solid #ddd;
        }
        #metrics-canvas {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .axis path, .axis line {
            fill: none;
            stroke: #888;
            shape-rendering: crispEdges;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 13px;
            max-width: 200px;
        }
        .cell {
            stroke: #ddd;
        }
        .button-container {
            margin-top: 20px;
        }
        .button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="title">Artificial Neurons that Matter: Reject Correlation, Embrace Orthogonality</div>
    <div id="abstract">
        This interactive visualization shows how orthogonal relationships in artificial neurons can impact spatial positioning. Click to add new neurons and observe how each cell is colored based on the nearest neuron's influence.
    </div>
        <div class="button-container">
            <button class="button" onclick="setSimilarityMetric('dotProduct')">Dot Product</button>
            <button class="button" onclick="setSimilarityMetric('euclidean')">Euclidean Distance</button>
            <button class="button" onclick="setSimilarityMetric('myProduct')">My Product</button>
        </div>
    <div id="container">
        <div id="main-canvas">
            <svg id="canvas" aria-labelledby="title" role="img"></svg>
        </div>
        <div id="metrics-canvas">
            <svg id="metrics" aria-labelledby="metrics" role="img"></svg>
            <svg id="barplot" aria-labelledby="neuron-magnitudes" role="img"></svg>
        </div>
        <div class="tooltip" style="display: none;" aria-hidden="true"></div>
    </div>

    <script>
        const container = document.getElementById('container');
        const svg = d3.select("#canvas")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", "0 0 600 600");

        const tooltip = d3.select(".tooltip");
        const width = 600;
        const height = 600;
        const numCells = 100;
        const cellSize = width / numCells;

        const neurons = [];
        const colorScale = d3.scaleSequential(d3.interpolateRainbow).domain([0, 1]);

        // Scales for positioning
        const xScale = d3.scaleLinear().domain([-numCells/2, numCells/2]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-numCells/2, numCells/2]).range([height, 0]);

        // Axes
        svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .attr("class", "axis")
            .call(d3.axisBottom(xScale).ticks(10));
        
        svg.append("g")
            .attr("class", "axis")
            .call(d3.axisLeft(yScale).ticks(10));

        // Create cells and append to SVG
        const cells = svg.selectAll(".cell")
            .data(d3.range(numCells * numCells))
            .enter().append("rect")
            .attr("class", "cell")
            .attr("width", cellSize)
            .attr("height", cellSize)
            .attr("x", d => (d % numCells) * cellSize)
            .attr("y", d => Math.floor(d / numCells) * cellSize)
            .on("mousemove", (event, d) => showTooltip(event, d))
            .on("mouseout", () => tooltip.style("display", "none"));

        // Add neuron by clicking
        svg.on("click", (event) => {
            const coords = d3.pointer(event);
            const neuron = { x: coords[0], y: coords[1], color: colorScale(neurons.length / 10) };
            neurons.push(neuron);

            // Draw neuron circle
            svg.append("circle")
                .attr("class", "neuron")
                .attr("cx", neuron.x)
                .attr("cy", neuron.y)
                .attr("r", 8)
                .style("fill", neuron.color);

            updateHeatmap();
        });

        let similarityMetric = 'dotProduct';

        function setSimilarityMetric(metric) {
            similarityMetric = metric;
            updateHeatmap();
        }

        function calculateScore(neuron, x, y) {
            // Convert pixel coordinates to scaled coordinates
            const scaledX = xScale.invert(x);
            const scaledY = yScale.invert(y);
            const scaledNeuronX = xScale.invert(neuron.x);
            const scaledNeuronY = yScale.invert(neuron.y);
            
            const dx = scaledX - scaledNeuronX;
            const dy = scaledY - scaledNeuronY;
            const squaredDistance = dx * dx + dy * dy + 1e-8;
            let value;

            if (similarityMetric === 'dotProduct') {
                const dotProductSquared = (scaledX * scaledNeuronX + scaledY * scaledNeuronY);
                value = dotProductSquared;
            } else if (similarityMetric === 'euclidean') {
                value = Math.sqrt(squaredDistance);
            } else if (similarityMetric === 'myProduct') {
                const dotProductSquared = (scaledX * scaledNeuronX + scaledY * scaledNeuronY) ** 2;
                value = dotProductSquared / squaredDistance;
            }

            return value;
        }

        // Setup metrics SVG
        const metricsWidth = 300;
        const metricsHeight = 300;
        const barplotHeight = 200;

        const metricsSvg = d3.select("#metrics")
            .attr("width", "100%")
            .attr("height", metricsHeight);

        const barplotSvg = d3.select("#barplot")
            .attr("width", "100%")
            .attr("height", barplotHeight);

        // Add function to calculate region areas
        function calculateNeuronMetrics() {
            const metrics = neurons.map((neuron, idx) => {
                const controlledCells = cells.filter(function() {
                    const cellData = d3.select(this).datum();
                    const i = cellData % numCells;
                    const j = Math.floor(cellData / numCells);
                    const x = (i - numCells/2) * cellSize;
                    const y = (j - numCells/2) * cellSize;
                    
                    let maxScore = -Infinity;
                    let winningNeuron = null;
                    neurons.forEach(n => {
                        const score = calculateScore(n, x, y);
                        if (score > maxScore) {
                            maxScore = score;
                            winningNeuron = n;
                        }
                    });
                    return winningNeuron === neuron;
                });
                
                return {
                    neuron,
                    area: controlledCells.size(),
                    magnitude: Math.sqrt(neuron.x * neuron.x + neuron.y * neuron.y)
                };
            });

            // Update bar plot
            const bars = barplotSvg.selectAll(".bar")
                .data(metrics)
                .join("rect")
                .attr("class", "bar")
                .attr("x", (d, i) => i * (metricsWidth / metrics.length))
                .attr("y", d => barplotHeight - (d.area / (numCells * numCells) * barplotHeight))
                .attr("width", metricsWidth / metrics.length - 2)
                .attr("height", d => (d.area / (numCells * numCells) * barplotHeight))
                .style("fill", d => d.neuron.color);

            // Update area plot
            metricsSvg.selectAll(".area-line")
                .data(metrics)
                .join("circle")
                .attr("class", "area-line")
                .attr("cx", d => Math.abs(d.neuron.x / width * metricsWidth))
                .attr("cy", d => Math.abs(d.neuron.y / height * metricsHeight))
                .attr("r", d => Math.sqrt(d.area) / 2)
                .style("fill", "none")
                .style("stroke", d => d.neuron.color)
                .style("stroke-width", 2);
        }

        // Calculate and update heatmap
        function updateHeatmap() {
            cells.style("fill", (d) => {
                const i = d % numCells;
                const j = Math.floor(d / numCells);
                const x = i * cellSize + cellSize / 2;
                const y = j * cellSize + cellSize / 2;

                if (neurons.length === 0) return "#fff";

                let maxScore = -Infinity;
                let winningNeuron = null;

                neurons.forEach((neuron) => {
                    const score = calculateScore(neuron, x, y);
                    if (score > maxScore) {
                        maxScore = score;
                        winningNeuron = neuron;
                    }
                });

                return winningNeuron ? winningNeuron.color : "#fff";
            });
            calculateNeuronMetrics();
        }

        function showTooltip(event, d) {
            const i = d % numCells;
            const j = Math.floor(d / numCells);
            const x = i * cellSize + cellSize / 2;
            const y = j * cellSize + cellSize / 2;
            
            // Convert pixel coordinates to scaled coordinates
            const scaledX = xScale.invert(x);
            const scaledY = yScale.invert(y);

            if (neurons.length === 0) return;

            let maxScore = -Infinity;
            let winningNeuron = null;

            neurons.forEach((neuron) => {
                const score = calculateScore(neuron, x, y);
                if (score > maxScore) {
                    maxScore = score;
                    winningNeuron = neuron;
                }
            });

            tooltip.html(`X: ${scaledX.toFixed(1)}, Y: ${scaledY.toFixed(1)}<br>Score: ${maxScore.toFixed(1)}<br>Winning Neuron Color: ${winningNeuron.color}`)
                .style("display", "block")
                .style("left", `${Math.min(event.pageX + 10, container.clientWidth - 100)}px`)
                .style("top", `${event.pageY - 40}px`)
                .attr("aria-hidden", "false");
        }
    </script>
</body>
</html>
