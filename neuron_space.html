<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artificial Neurons that Matter: Reject Correlation, Embrace Orthogonality</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
        }
        #title {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        #abstract {
            max-width: 700px;
            text-align: center;
            color: #555;
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
        }
        #container {
            position: relative;
            width: 80vw;
            height: 80vh;
            max-width: 600px;
            max-height: 600px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .axis path, .axis line {
            fill: none;
            stroke: #888;
            shape-rendering: crispEdges;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 13px;
            max-width: 200px;
        }
        .cell {
            stroke: #ddd;
        }
    </style>
</head>
<body>
    <div id="title">Artificial Neurons that Matter: Reject Correlation, Embrace Orthogonality</div>
    <div id="abstract">
        This interactive visualization shows how orthogonal relationships in artificial neurons can impact spatial positioning. Click to add new neurons and observe how each cell is colored based on the nearest neuron's influence.
    </div>
    <div id="container">
        <svg id="canvas" aria-labelledby="title" role="img"></svg>
        <div class="tooltip" style="display: none;" aria-hidden="true"></div>
    </div>

    <script>
        const container = document.getElementById('container');
        const svg = d3.select("#canvas")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", "0 0 600 600");

        const tooltip = d3.select(".tooltip");
        const width = 600;
        const height = 600;
        const numCells = 100;
        const cellSize = width / numCells;

        const neurons = [];
        const colorScale = d3.scaleSequential(d3.interpolateRainbow).domain([0, 1]);

        // Scales for positioning
        const xScale = d3.scaleLinear().domain([0, numCells]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, numCells]).range([height, 0]);

        // Axes
        svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .attr("class", "axis")
            .call(d3.axisBottom(xScale).ticks(10));
        
        svg.append("g")
            .attr("class", "axis")
            .call(d3.axisLeft(yScale).ticks(10));

        // Create cells and append to SVG
        const cells = svg.selectAll(".cell")
            .data(d3.range(numCells * numCells))
            .enter().append("rect")
            .attr("class", "cell")
            .attr("width", cellSize)
            .attr("height", cellSize)
            .attr("x", d => (d % numCells) * cellSize)
            .attr("y", d => Math.floor(d / numCells) * cellSize)
            .on("mousemove", (event, d) => showTooltip(event, d))
            .on("mouseout", () => tooltip.style("display", "none"));

        // Add neuron by clicking
        svg.on("click", (event) => {
            const coords = d3.pointer(event);
            const neuron = { x: coords[0], y: coords[1], color: colorScale(neurons.length / 10) };
            neurons.push(neuron);

            // Draw neuron circle
            svg.append("circle")
                .attr("class", "neuron")
                .attr("cx", neuron.x)
                .attr("cy", neuron.y)
                .attr("r", 8)
                .style("fill", neuron.color);

            updateHeatmap();
        });

        function calculateScore(neuron, x, y) {
            const dx = x - neuron.x;
            const dy = y - neuron.y;
            const squaredDistance = dx * dx + dy * dy + 1e-8;
            const dotProductSquared = (x * neuron.x + y * neuron.y) ** 2;
            return dotProductSquared / squaredDistance;
        }

        // Calculate and update heatmap
        function updateHeatmap() {
            cells.style("fill", (d) => {
                const i = d % numCells;
                const j = Math.floor(d / numCells);
                const x = i * cellSize + cellSize / 2;
                const y = j * cellSize + cellSize / 2;

                if (neurons.length === 0) return "#fff";

                let maxScore = -Infinity;
                let winningNeuron = null;

                neurons.forEach((neuron) => {
                    const score = calculateScore(neuron, x, y);
                    if (score > maxScore) {
                        maxScore = score;
                        winningNeuron = neuron;
                    }
                });

                return winningNeuron ? winningNeuron.color : "#fff";
            });
        }

        function showTooltip(event, d) {
            const i = d % numCells;
            const j = Math.floor(d / numCells);
            const x = i * cellSize + cellSize / 2;
            const y = j * cellSize + cellSize / 2;

            if (neurons.length === 0) return;

            let maxScore = -Infinity;
            let winningNeuron = null;

            neurons.forEach((neuron) => {
                const score = calculateScore(neuron, x, y);
                if (score > maxScore) {
                    maxScore = score;
                    winningNeuron = neuron;
                }
            });

            tooltip.html(`X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}<br>Winning Neuron Color: ${winningNeuron.color}`)
                .style("display", "block")
                .style("left", `${Math.min(event.pageX + 10, container.clientWidth - 100)}px`)
                .style("top", `${event.pageY - 40}px`)
                .attr("aria-hidden", "false");
        }
    </script>
</body>
</html>
