<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artificial Neurons that Matter: Reject Correlation, Embrace Orthogonality</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
        }
        #title {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        #abstract {
            max-width: 700px;
            text-align: center;
            color: #555;
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
        }
        #container {
            position: relative;
            width: 80vw;
            height: 80vh;
            max-width: 600px;
            max-height: 600px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .axis path, .axis line {
            fill: none;
            stroke: #888;
            shape-rendering: crispEdges;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 13px;
            max-width: 200px;
        }
        .cell {
            stroke: #ddd;
        }
        .button-container {
            margin-top: 20px;
        }
        .button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="title">Artificial Neurons that Matter: Reject Correlation, Embrace Orthogonality</div>
    <div id="abstract">
        This interactive visualization shows how orthogonal relationships in artificial neurons can impact spatial positioning. Click to add new neurons and observe how each cell is colored based on the nearest neuron's influence.
    </div>
    <div id="container">
        <svg id="canvas" aria-labelledby="title" role="img"></svg>
        <div class="tooltip" style="display: none;" aria-hidden="true"></div>
    </div>
    <div class="button-container">
        <button class="button" onclick="setSimilarityMetric('dotProduct')">Dot Product</button>
        <button class="button" onclick="setSimilarityMetric('euclidean')">Euclidean Distance</button>
        <button class="button" onclick="setSimilarityMetric('myProduct')">My Product</button>
    </div>

    <script>
        const container = document.getElementById('container');
        const svg = d3.select("#canvas")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", "0 0 600 600");

        const tooltip = d3.select(".tooltip");
        const width = 600;
        const height = 600;
        const numCells = 100;
        const cellSize = width / numCells;

        const neurons = [];
        const colorScale = d3.scaleSequential(d3.interpolateRainbow).domain([0, 1]);

        // Scales for positioning
        const xScale = d3.scaleLinear().domain([0, numCells]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, numCells]).range([height, 0]);

        // Axes
        svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .attr("class", "axis")
            .call(d3.axisBottom(xScale).ticks(10));
        
        svg.append("g")
            .attr("class", "axis")
            .call(d3.axisLeft(yScale).ticks(10));

        // Create cells and append to SVG
        const cells = svg.selectAll(".cell")
            .data(d3.range(numCells * numCells))
            .enter().append("rect")
            .attr("class", "cell")
            .attr("width", cellSize)
            .attr("height", cellSize)
            .attr("x", d => (d % numCells) * cellSize)
            .attr("y", d => Math.floor(d / numCells) * cellSize)
            .on("mousemove", (event, d) => showTooltip(event, d))
            .on("mouseout", () => tooltip.style("display", "none"));

        // Add neuron by clicking
        svg.on("click", (event) => {
            const coords = d3.pointer(event);
            const neuron = { x: coords[0], y: coords[1], color: colorScale(neurons.length / 10) };
            neurons.push(neuron);

            // Draw neuron circle
            svg.append("circle")
                .attr("class", "neuron")
                .attr("cx", neuron.x)
                .attr("cy", neuron.y)
                .attr("r", 8)
                .style("fill", neuron.color);

            updateHeatmap();
        });

        let similarityMetric = 'dotProduct';

        function setSimilarityMetric(metric) {
            similarityMetric = metric;
            updateHeatmap();
        }

        function calculateScore(neuron, x, y) {
            const dx = x - neuron.x;
            const dy = y - neuron.y;
            const squaredDistance = dx * dx + dy * dy + 1e-8;
            let value;

            if (similarityMetric === 'dotProduct') {
                const dotProductSquared = (x * neuron.x + y * neuron.y);
                value = dotProductSquared;
            } else if (similarityMetric === 'euclidean') {
                value = Math.sqrt(squaredDistance);
            } else if (similarityMetric === 'myProduct') {
                const dotProductSquared = (x * neuron.x + y * neuron.y) ** 2;
                value = dotProductSquared / squaredDistance;
            }

            return value;
        }

        // Calculate and update heatmap
        function updateHeatmap() {
            cells.style("fill", (d) => {
                const i = d % numCells;
                const j = Math.floor(d / numCells);
                const x = i * cellSize + cellSize / 2;
                const y = j * cellSize + cellSize / 2;

                if (neurons.length === 0) return "#fff";

                let maxScore = -Infinity;
                let winningNeuron = null;

                neurons.forEach((neuron) => {
                    const score = calculateScore(neuron, x, y);
                    if (score > maxScore) {
                        maxScore = score;
                        winningNeuron = neuron;
                    }
                });

                return winningNeuron ? winningNeuron.color : "#fff";
            });
        }

        function showTooltip(event, d) {
            const i = d % numCells;
            const j = Math.floor(d / numCells);
            const x = i * cellSize + cellSize / 2;
            const y = j * cellSize + cellSize / 2;

            if (neurons.length === 0) return;

            let maxScore = -Infinity;
            let winningNeuron = null;

            neurons.forEach((neuron) => {
                const score = calculateScore(neuron, x, y);
                if (score > maxScore) {
                    maxScore = score;
                    winningNeuron = neuron;
                }
            });

            tooltip.html(`X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}<br>Winning Neuron Color: ${winningNeuron.color}`)
                .style("display", "block")
                .style("left", `${Math.min(event.pageX + 10, container.clientWidth - 100)}px`)
                .style("top", `${event.pageY - 40}px`)
                .attr("aria-hidden", "false");
        }
    </script>
</body>
</html>
