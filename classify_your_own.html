<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NNMap and CYOD: Classify your Own Dataset </title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
        }
        #title {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        #abstract {
            max-width: 700px;
            text-align: center;
            color: #555;
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
        }
        #container {
            display: flex;
            gap: 20px;
            width: 100vw;
            height: 85vh;
            max-width: 1200px;
            max-height: 700px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #main-canvas {
            flex: 2;
            border-right: 1px solid #ddd;
        }
        #metrics-canvas {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .axis path, .axis line {
            fill: none;
            stroke: #888;
            shape-rendering: crispEdges;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 13px;
            max-width: 200px;
        }
        .cell {
            stroke: #ddd;
        }
        .button-container {
            margin-top: 20px;
        }
        .button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
        }
        .data-point {
            fill-opacity: 0.7;
            stroke: #333;
            stroke-width: 1;
        }
        .file-input {
            margin: 10px 0;
        }
        .accuracy-display {
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            width: fit-content;
        }
        .class-toggle {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
            border: 2px solid;
            border-radius: 4px;
            color: white;
            text-shadow: 0 0 2px #000;
        }
        .class-toggle.active {
            filter: brightness(100%);
        }
        .class-toggle:not(.active) {
            filter: brightness(50%);
        }
        .button.selected {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #45a049;
        }
        .similarity-button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid #ddd;
            border-radius: 4px;
            background-color: white;
            transition: all 0.3s ease;
            opacity: 0.7;
        }
        .similarity-button:hover {
            opacity: 0.9;
        }
        .similarity-button.selected {
            background-color: #4CAF50;
            color: white;
            border-color: #45a049;
            opacity: 1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .similarity-button:not(.selected) {
            background-color: #f5f5f5;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="title">NNMap and CYOD: Classify your Own Dataset</div>
    <div id="abstract">
        Upload your data that contains x, y, and label, than create your own neural network by clicking on the canvas to add neurons. Load a CSV file with data points to see how the neurons classify the data. Change the similarity metric to see how it affects the classification. Click on a class to toggle its visibility.
        <br><br>
        Features:
        <ul>
            <li>Upload CSV data containing x, y, and label.</li>
            <li>Create a neural network by clicking on the canvas to add neurons.</li>
            <li>Load and save neuron weights from/to a CSV file.</li>
            <li>Choose different similarity metrics: Dot Product, Euclidean Distance, My Product.</li>
            <li>Toggle between actual and predicted colors for data points.</li>
            <li>Show or hide decision boundaries.</li>
            <li>Select activation functions: None, Softmax, Softermax, Sigmoid, ReLU, GELU.</li>
        </ul>
    </div>
    <div class="file-input">
        <input type="file" id="csvFile" accept=".csv" />
        <button class="button" onclick="loadCSV()">Load Data</button>
        <input type="file" id="neuronFile" accept=".csv" />
        <button class="button" onclick="loadNeurons()">Load Neurons</button>
        <button class="button" onclick="saveNeurons()">Save Neurons</button>
    </div>
    <div class="button-container">
        <button class="similarity-button selected" data-metric="dotProduct" onclick="setSimilarityMetric('dotProduct')">Dot Product</button>
        <button class="similarity-button" data-metric="euclidean" onclick="setSimilarityMetric('euclidean')">Euclidean Distance</button>
        <button class="similarity-button" data-metric="myProduct" onclick="setSimilarityMetric('myProduct')">My Product</button>
        <button class="button" id="colorModeToggle" onclick="toggleColorMode()">Show Actual Colors</button>
        <button class="button" onclick="removeLastNeuron()">Remove Last Neuron</button>
        <button class="button" id="boundaryToggle" onclick="toggleBoundaries()">Show Boundaries</button>
        <select id="activationFunction" class="button" onchange="setActivationFunction(this.value)">
            <option value="none">None</option>
            <option value="softmax">Softmax</option>
            <option value="softermax">Softermax</option>
            <option value="sigmoid">Sigmoid</option>
            <option value="xmoid">xmoid</option>
            <option value="logmoid">logmoid</option>
            <option value="relu">ReLU</option>
            <option value="gelu">GELU</option>
        </select>
    </div>
    <div id="class-toggle-container" class="button-container"></div>
    <div id="container">
        <div id="main-canvas">
            <svg id="canvas" aria-labelledby="title" role="img"></svg>
            <div class="accuracy-display">
                Accuracy: <span id="accuracy-value">-</span><br>
                Classes: <span id="class-count">-</span><br>
                Neurons: <span id="neuron-count">-</span>
            </div>
        </div>
        <div id="metrics-canvas">
            <svg id="metrics" aria-labelledby="metrics" role="img"></svg>
            <svg id="barplot" aria-labelledby="neuron-magnitudes" role="img"></svg>
        </div>
        <div class="tooltip" style="display: none;" aria-hidden="true"></div>
    </div>

    <div id="math-formulas">
        <h3>Math Formulas for Activation Functions</h3>
        <p><strong>Softmax:</strong></p>
        <p>\[
        \text{softmax}(x_i) = \frac{e^{x_i}}{\sum_{j} e^{x_j}}
        \]</p>
        <p><strong>Softermax:</strong></p>
        <p>\[
        \text{softermax}(x_i) = \frac{1 + x_i}{\sum_{j} (1 + x_j)}
        \]</p>
        <p><strong>Sigmoid:</strong></p>
        <p>\[
        \text{sigmoid}(x) = \frac{1}{1 + e^{-x}}
        \]</p>
        <p><strong>ReLU:</strong></p>
        <p>\[
        \text{ReLU}(x) = \max(0, x)
        \]</p>
        <p><strong>GELU:</strong></p>
        <p>\[
        \text{GELU}(x) = 0.5 \cdot x \cdot \left(1 + \tanh\left(\sqrt{\frac{2}{\pi}} \left(x + 0.044715 \cdot x^3\right)\right)\right)
        \]</p>
    </div>

    <script>
        const container = document.getElementById('container');
        const svg = d3.select("#canvas")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", "0 0 600 600");

        const tooltip = d3.select(".tooltip");
        const width = 600;
        const height = 600;
        const numCells = 100;
        const cellSize = width / numCells;

        const neurons = [];
        const colorScale = d3.scaleSequential(d3.interpolateRainbow).domain([0, 10]);  // Changed domain to 10 for better color distribution

        // Scales for positioning
        const xScale = d3.scaleLinear().domain([-numCells/2, numCells/2]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-numCells/2, numCells/2]).range([height, 0]);

        // Add after other constant declarations in the script
        const scoreScale = d3.scaleLinear()
            .domain([-1, 1])  // Adjust domain based on your score range
            .range([0, 1]);   // For opacity/intensity

        // Axes
        svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .attr("class", "axis")
            .call(d3.axisBottom(xScale).ticks(10));
        
        svg.append("g")
            .attr("class", "axis")
            .call(d3.axisLeft(yScale).ticks(10));

        // Create cells and append to SVG
        const cells = svg.selectAll(".cell")
            .data(d3.range(numCells * numCells))
            .enter().append("rect")
            .attr("class", "cell")
            .attr("width", cellSize)
            .attr("height", cellSize)
            .attr("x", d => (d % numCells) * cellSize)
            .attr("y", d => Math.floor(d / numCells) * cellSize)
            .on("mousemove", (event, d) => showTooltip(event, d))
            .on("mouseout", () => tooltip.style("display", "none"));

        // Add neuron by clicking
        svg.on("click", (event) => {
            const coords = d3.pointer(event);
            const neuronIndex = neurons.length;
            const neuron = {
                x: coords[0],
                y: coords[1],
                color: colorScale(neuronIndex),  // Use same index for color
                index: neuronIndex
            };
            neurons.push(neuron);

            // Draw neuron circle
            svg.append("circle")
                .attr("class", "neuron")
                .attr("cx", neuron.x)
                .attr("cy", neuron.y)
                .attr("r", 8)
                .style("fill", neuron.color);

            document.getElementById('neuron-count').textContent = neurons.length;

            updateVisualization();
            updateAccuracyDisplay();
        });

        let similarityMetric = 'dotProduct';
        let showPredictedColors = true;
        const classColorScale = d3.scaleOrdinal(d3.schemeCategory10);
        let showBoundaries = false;
        let activationFunction = 'none';

        function setSimilarityMetric(metric) {
            similarityMetric = metric;
            // Update button styles
            document.querySelectorAll('.similarity-button').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.metric === metric);
            });
            updateHeatmap();
            updateAccuracyDisplay();
        }

        function setActivationFunction(func) {
            activationFunction = func;
            updateHeatmap();
            updateAccuracyDisplay();
        }

        function applyActivationFunction(scores) {
            if (activationFunction === 'softmax') {
                const maxScore = Math.max(...scores);
                const expScores = scores.map(score => Math.exp(score - maxScore));
                const sumExpScores = expScores.reduce((a, b) => a + b, 0);
                return expScores.map(score => score / sumExpScores);
            } else if (activationFunction === 'softermax') {
                const transformedScores = scores.map(score => 1 + score);
                const sumTransformedScores = transformedScores.reduce((a, b) => a + b, 0);
                return transformedScores.map(score => score / sumTransformedScores);
            } else if (activationFunction === 'sigmoid') {
                return scores.map(score => 1 / (1 + Math.exp(-score)));
            } else if (activationFunction === 'xmoid') {
                return scores.map(score => 1 / (1 + score));
            } else if (activationFunction === 'logmoid') {
                return scores.map(score => 1 / (1 + Math.log(score)));
            } else if (activationFunction === 'relu') {
                return scores.map(score => Math.max(0, score));
            } else if (activationFunction === 'gelu') {
                return scores.map(score => 0.5 * score * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (score + 0.044715 * Math.pow(score, 3)))));
            } else {
                return scores; // None
            }
        }

        function toggleColorMode() {
            showPredictedColors = !showPredictedColors;
            document.getElementById('colorModeToggle').textContent = 
                showPredictedColors ? 'Show Actual Colors' : 'Show Predicted Colors';
            updateVisualization();
        }

        function toggleBoundaries() {
            showBoundaries = !showBoundaries;
            document.getElementById('boundaryToggle').textContent = 
                showBoundaries ? 'Hide Boundaries' : 'Show Boundaries';
            updateHeatmap();
        }

        function calculateScore(neuron, x, y) {
            // Convert pixel coordinates to scaled coordinates
            const scaledX = xScale.invert(x);
            const scaledY = yScale.invert(y);
            const scaledNeuronX = xScale.invert(neuron.x);
            const scaledNeuronY = yScale.invert(neuron.y);
            
            const dx = scaledX - scaledNeuronX;
            const dy = scaledY - scaledNeuronY;
            const squaredDistance = dx * dx + dy * dy + 1e-8;
            let value;

            if (similarityMetric === 'dotProduct') {
                const dotProductSquared = (scaledX * scaledNeuronX + scaledY * scaledNeuronY);
                value = dotProductSquared;
            } else if (similarityMetric === 'euclidean') {
                value = Math.sqrt(squaredDistance);
            } else if (similarityMetric === 'myProduct') {
                const dotProductSquared = (scaledX * scaledNeuronX + scaledY * scaledNeuronY) ** 2;
                value = dotProductSquared / squaredDistance;
            }

            return value;
        }

        // Setup metrics SVG
        const metricsWidth = 300;
        const metricsHeight = 300;
        const barplotHeight = 200;

        const metricsSvg = d3.select("#metrics")
            .attr("width", "100%")
            .attr("height", metricsHeight);

        const barplotSvg = d3.select("#barplot")
            .attr("width", "100%")
            .attr("height", barplotHeight);

        // Add function to calculate region areas
        function calculateNeuronMetrics() {
            const metrics = neurons.map((neuron, idx) => {
                const controlledCells = cells.filter(function() {
                    const cellData = d3.select(this).datum();
                    const i = cellData % numCells;
                    const j = Math.floor(cellData / numCells);
                    const x = (i - numCells/2) * cellSize;
                    const y = (j - numCells/2) * cellSize;
                    
                    let maxScore = -Infinity;
                    let winningNeuron = null;
                    neurons.forEach(n => {
                        const score = calculateScore(n, x, y);
                        if (score > maxScore) {
                            maxScore = score;
                            winningNeuron = n;
                        }
                    });
                    return winningNeuron === neuron;
                });
                
                return {
                    neuron,
                    area: controlledCells.size(),
                    magnitude: neuron.x * neuron.x + neuron.y * neuron.y  // Squared magnitude
                };
            });

            // Update bar plot
            const bars = barplotSvg.selectAll(".bar")
                .data(metrics)
                .join("rect")
                .attr("class", "bar")
                .attr("x", (d, i) => i * (metricsWidth / metrics.length))
                .attr("y", d => barplotHeight - (d.area / (numCells * numCells) * barplotHeight))
                .attr("width", metricsWidth / metrics.length - 2)
                .attr("height", d => (d.area / (numCells * numCells) * barplotHeight))
                .style("fill", d => d.neuron.color);

            // Update area plot
            metricsSvg.selectAll(".area-line")
                .data(metrics)
                .join("circle")
                .attr("class", "area-line")
                .attr("cx", d => Math.abs(d.neuron.x / width * metricsWidth))
                .attr("cy", d => Math.abs(d.neuron.y / height * metricsHeight))
                .attr("r", d => Math.sqrt(d.area) / 2)
                .style("fill", "none")
                .style("stroke", d => d.neuron.color)
                .style("stroke-width", 2);
        }

        // Calculate and update heatmap
        function updateHeatmap() {
            cells.style("fill", (d) => {
                const i = d % numCells;
                const j = Math.floor(d / numCells);
                const x = i * cellSize + cellSize / 2;
                const y = j * cellSize + cellSize / 2;

                if (neurons.length === 0) return "#fff";

                let scores = neurons.map(neuron => calculateScore(neuron, x, y));
                scores = applyActivationFunction(scores);

                let maxScore = Math.max(...scores);
                let secondBestScore = scores.reduce((max, score) => 
                    score < maxScore && score > max ? score : max, -Infinity);
                let winningNeuron = neurons[scores.indexOf(maxScore)];

                if (!showBoundaries) {
                    return winningNeuron ? winningNeuron.color : "#fff";
                } else {
                    // For boundary visualization, use activated scores directly
                    const confidence = Math.max(0, 1 - (secondBestScore / (maxScore + 1e-8)));
                    return winningNeuron ? 
                        d3.color(winningNeuron.color).copy({opacity: confidence}) : 
                        "#fff";
                }
            });

            svg.selectAll('.data-point')
                .style('fill', d => {
                    if (showPredictedColors) {
                        if (neurons.length === 0) return '#999';
                        
                        let scores = neurons.map(neuron => calculateScore(neuron, d.x, d.y));
                        scores = applyActivationFunction(scores);
                        let maxScore = Math.max(...scores);
                        let winningNeuron = neurons[scores.indexOf(maxScore)];
                        
                        const normalizedScore = scoreScale(maxScore);
                        return winningNeuron ? 
                            d3.color(winningNeuron.color).copy({opacity: normalizedScore}) : 
                            '#999';
                    } else {
                        return colorScale(d.originalLabel);
                    }
                });

            calculateNeuronMetrics();
        }

        function showTooltip(event, d) {
            const i = d % numCells;
            const j = Math.floor(d / numCells);
            const x = i * cellSize + cellSize / 2;
            const y = j * cellSize + cellSize / 2;
            
            // Convert pixel coordinates to scaled coordinates
            const scaledX = xScale.invert(x);
            const scaledY = yScale.invert(y);

            if (neurons.length === 0) return;

            let rawScores = neurons.map(neuron => calculateScore(neuron, x, y));
            let activatedScores = applyActivationFunction(rawScores);
            
            let scores = neurons.map((neuron, idx) => ({
                neuron: neuron,
                raw: rawScores[idx],
                activated: activatedScores[idx]
            })).sort((a, b) => b.activated - a.activated);

            let scoreText = scores.map(s => 
                `<span style="color: ${s.neuron.color}">Neuron ${s.neuron.index}: ${s.activated.toFixed(3)} (raw: ${s.raw.toFixed(3)})</span>`
            ).join('<br>');

            tooltip.html(`X: ${scaledX.toFixed(1)}, Y: ${scaledY.toFixed(1)}<br>${scoreText}`)
                .style("display", "block")
                .style("left", `${Math.min(event.pageX + 10, container.clientWidth - 100)}px`)
                .style("top", `${event.pageY - 40}px`)
                .attr("aria-hidden", "false");
        }

        const dataPoints = [];
        let activeClasses = new Set();
        let allClasses = new Set();

        function loadCSV() {
            const file = document.getElementById('csvFile').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const csvData = event.target.result;
                    const rows = csvData.split('\n');
                    dataPoints.length = 0; // Clear existing data
                    allClasses.clear();
                    activeClasses.clear();
                    
                    rows.forEach(row => {
                        const [x, y, label] = row.split(',').map(v => parseFloat(v.trim()));
                        if (!isNaN(x) && !isNaN(y)) {
                            allClasses.add(label);
                            activeClasses.add(label);
                            dataPoints.push({ x: xScale(x), y: yScale(y), originalLabel: label });
                        }
                    });
                    
                    document.getElementById('class-count').textContent = allClasses.size;
                    createClassToggles();
                    updateVisualization();
                    updateAccuracyDisplay();
                };
                reader.readAsText(file);
            }
        }

        function loadNeurons() {
            const file = document.getElementById('neuronFile').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const csvData = event.target.result;
                    const rows = csvData.split('\n');
                    
                    // Clear existing neurons
                    neurons.length = 0;
                    svg.selectAll('.neuron').remove();
                    
                    rows.forEach(row => {
                        const [x, y, id] = row.split(',').map(v => parseFloat(v.trim()));
                        if (!isNaN(x) && !isNaN(y) && !isNaN(id)) {
                            const neuron = {
                                x: xScale(x),
                                y: yScale(y),
                                color: colorScale(neurons.length),
                                index: id
                            };
                            neurons.push(neuron);

                            // Draw neuron circle
                            svg.append("circle")
                                .attr("class", "neuron")
                                .attr("cx", neuron.x)
                                .attr("cy", neuron.y)
                                .attr("r", 8)
                                .style("fill", neuron.color);
                        }
                    });
                    
                    document.getElementById('neuron-count').textContent = neurons.length;
                    updateVisualization();
                    updateAccuracyDisplay();
                };
                reader.readAsText(file);
            }
        }

        function saveNeurons() {
            if (neurons.length === 0) {
                alert('No neurons to save!');
                return;
            }

            // Convert neurons to CSV format
            const csvContent = neurons.map(neuron => {
                // Convert back from screen coordinates to data coordinates
                const x = xScale.invert(neuron.x);
                const y = yScale.invert(neuron.y);
                return `${x},${y},${neuron.index}`;
            }).join('\n');

            // Create a blob and download link
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'neurons.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function createClassToggles() {
            const container = document.getElementById('class-toggle-container');
            container.innerHTML = '';
            
            allClasses.forEach(classLabel => {
                const button = document.createElement('button');
                button.className = `class-toggle ${activeClasses.has(classLabel) ? 'active' : ''}`;
                button.textContent = `Class ${classLabel}`;
                const classColor = colorScale(classLabel);
                button.style.backgroundColor = classColor;
                button.style.borderColor = classColor;
                button.onclick = () => toggleClass(classLabel);
                container.appendChild(button);
            });
        }

        function toggleClass(classLabel) {
            if (activeClasses.has(classLabel)) {
                activeClasses.delete(classLabel);
            } else {
                activeClasses.add(classLabel);
            }
            
            document.querySelectorAll('.class-toggle').forEach(btn => {
                if (btn.textContent === `Class ${classLabel}`) {
                    btn.classList.toggle('active');
                }
            });
            
            updateVisualization();
            updateAccuracyDisplay();
        }

        function updateVisualization() {
            // Clear existing data points
            svg.selectAll('.data-point').remove();
            
            const filteredPoints = dataPoints.filter(d => activeClasses.has(d.originalLabel));
            
            // Add data points
            svg.selectAll('.data-point')
                .data(filteredPoints)
                .enter()
                .append('circle')
                .attr('class', 'data-point')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', 5)
                .style('fill', d => {
                    if (showPredictedColors) {
                        if (neurons.length === 0) {
                            return '#999'; // Default color when no neurons
                        }
                        // Color based on winning neuron
                        let maxScore = -Infinity;
                        let winningNeuron = null;
                        neurons.forEach(neuron => {
                            const score = calculateScore(neuron, d.x, d.y);
                            if (score > maxScore) {
                                maxScore = score;
                                winningNeuron = neuron;
                            }
                        });
                        return winningNeuron ? winningNeuron.color : '#999';
                    } else {
                        return colorScale(d.originalLabel);  // Use same colorScale
                    }
                });
            
            updateAccuracyDisplay();
            updateHeatmap();
        }

        function calculateAccuracy() {
            if (dataPoints.length === 0 || neurons.length === 0) return 0;

            const filteredPoints = dataPoints.filter(d => activeClasses.has(d.originalLabel));
            if (filteredPoints.length === 0) return 0;

            let totalScore = 0;
            filteredPoints.forEach(point => {
                let scores = neurons.map(neuron => calculateScore(neuron, point.x, point.y));
                scores = applyActivationFunction(scores);
                let maxScore = Math.max(...scores);
                let predictedNeuronIndex = scores.indexOf(maxScore);

                if (neurons[predictedNeuronIndex].index === point.originalLabel) {
                    totalScore += 1;
                }
            });

            return (totalScore / filteredPoints.length) * 100;
        }

        function updateAccuracyDisplay() {
            const accuracy = calculateAccuracy();
            const activePointCount = dataPoints.filter(d => activeClasses.has(d.originalLabel)).length;
            document.getElementById('accuracy-value').textContent = 
                `${accuracy.toFixed(1)}% (${activePointCount} points) - ${similarityMetric}`;
        }

        function removeLastNeuron() {
            if (neurons.length > 0) {
                neurons.pop();
                // Remove last neuron circle
                svg.selectAll('.neuron').filter((d, i, nodes) => i === nodes.length - 1).remove();
                
                document.getElementById('neuron-count').textContent = neurons.length;
                updateVisualization();
                updateAccuracyDisplay();
            }
        }

    </script>
</body>
</html>
